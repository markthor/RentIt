\documentclass[a4paper,11pt,report]{article}
\usepackage[pdftex]{graphicx}
\usepackage{mathtools}
\usepackage[margin=1in]{geometry}
\usepackage{float}
\usepackage{lscape}
\usepackage{pdfpages}
\usepackage{epsfig}
\usepackage{epstopdf}
\DeclareGraphicsExtensions{.pdf,.png,.jpg,.eps}
\setlength{\parindent}{0in}
\begin{document}

\title{RentIt}
\author{Andreas Precht Poulsen, Morten F. Therkildsen, Mark Thorhauge, Toke Loke \& Mikkel Funch}
\date{28-05-2013}
\maketitle

\section{Introduction}
\subsection{Vision}
RentIt is a radio hosting service, that enables users to host online radio stations and for other users to listen to them.
It is a system intended to be used by the common user, without any special knowledge or traning.
\subsection{Glossary}
Track: An audio file that the users can listen to via channels. \\*
Channel: A collection of tracks that is played infinitly, and can be listen to by users. Managed by a channel host.

\section{Specification}
This section contains the fucntional and non-functional requirements, as well as the use cases that they are based on.
\subsection{Use Cases}
\textbf{Create account:}
The user navigates to the "create account"/"register" page. He fills out required information and agrees on eventual conditions.

\textbf{Delete account:}
The user does not want to use the service any longer, he has chosen to delete his account. All data about the user is deleted accordingly

\textbf{Listen to channel:}
The user navigates to the channel, possibly by searching for it and selects listen to channel.

\textbf{Subscribe to channel:}
The user has selected a channel and selects subscribe to channel. The subscription status changes accordingly.

\textbf{Unsubscribe to channel:}
The user has selected a channel and selects unsubsribe to channel, if he/she is already subscribed. The subscription status changes accordingly.

\textbf{Comment channel:}
The user is on a channel and want to comment on it. He writes his message and submits the comment. The comment is saved and the page is refreshed

\textbf{Create channel:}
The user navigates to "create channel" and fills out the required information as well as uploading tracks. When the user is done it is immediatly accessible by other users.

\textbf{Delete channel:}
The creater of the channel does not want the channel anymore and he decides to delete it. All subscriptions to the channel is deleted, subscribers gets notified, and the channel is removed.

\textbf{Upload track:}
The user has a channel and wants to upload a song. He selects the song through a filebrowser and selects upload.

\textbf{Delete track:}
The owner of a channel wants to remove a track from his channel. He browses the list of tracks and selects remove on the track he wants to remove.

\textbf{Edit channel:}
The owner of the channel selects edit channel and edits the channel attributes he wants to change. Then he confirmes the changes.

\textbf{Upvote/downvote track:}
The listener of a channel selects up- or downvote on a list of the last tracks that has been played.

\subsection{Functional requirements}
The functional requirements describe the required functionality of the system and defines enumerations for reference.
\\ \\
\textbf{R0:}
The system shall allow all users to create a channel, add attributes and edit it.
\textbf{Domain concepts:}
The channel shall have its own collection of tracks that it plays and it is created and maintained by the channel host(the creator of the channel).\\*
The channel shall have genres, a description and comments posted by users.\\*
The channel must be visible to other users with prober search parameters.
\textbf{Dependencies:}
The requirement is nessecary for upload track and listen to channel because a track is associated with a channel.
\textbf{Priority:}
It is of essential importance, as the requirements depending on it is.
\\ \\

\textbf{R1:}
The system must allow users to listen to online radio-channel that streams audio. \\*
\textbf{Domain concepts:}
A channel has a collection of tracks that can be listened to. \\*
\textbf{Priority:}
Highest as this is the primary service that the system provides. \\*
\textbf{Implementation notes:}
The system must be able to stream audio in a smooth and clutter-free manner. The system must have an intelligent way of selecting the next track to be played, meaning that it must consider up/downvotes and how much it has been played.
A radio-channel must be able to stream an endless stream of audio without pauses between audio tracks.
The streaming must be implemented as a webservice(Windows Communication Foundation) and it must be
easy to write a new clients for the service.
The interface for listening to audio must be as user friendly as possible.
\\ \\

\textbf{R2:}
The user must be able to rate a track associated with a channel. \\*
\textbf{Domain concepts:}
The rating of a track must affect the frequency with which it is played within its associated channel.
A higher rating giving a proportionally higher chance of being played. \\*
\textbf{Dependencies:}
The listen to channel requirement are depended on this requirement because the track to be played is determined by the rating.\\*
\textbf{Priority:}
It is of essential importance, as the requirements depending on it is.
\\ \\

\textbf{R3:}
It should be possible for users with a channel to upload a track to it. \\*
\textbf{Domain concepts:}
A channel has tracks that the creator manages. \\*
\textbf{Dependencies:}
The listen to channel requirement are depended on this requirement because the track to be played is determined by the rating.\\*
\textbf{Priority:}
It is of essential importance, as the requirements depending on it is.
 \\ \\

\subsection{Non-functional requirements}
The non-functional requirements describes how the functionality shall work in multiple aspects, as well as defining success criteria for them. They are structured with FURPS+. \\

\textbf{Functionality} \\*
\textit{Channels} \\*
Channel owners must be able to assign genre tags to the channels they control/own. \\*
Two users listening to the same channel at the same time must hear the same song with same amount of elapsed time (+- 1s), in other words, a channel is "playing" the same for all listeners. \\*
A function for searching for channels must be implemented. \\*
A list of the most popular channels should be available to all users. Popularity must be based on an algorithm and it must be explained in the documentation. \\*

\textit{Tracks} \\*
The service must support tracks in .mp3 format. \\*

\textit{Logging and Error Handling} \\*
All exceptional states must be logged.\\*
All state changes must be logged.\\*

\textit{Security} \\*
All usage requires authentication. (usage meaning the use of any services related to the program)\\*

\textbf{Usability} \\*
The website should be intuitive to use for 90\% of persons above the age of 12 with regard to the following:
\begin{itemize}
\item listening to a channel
\item maintaining one. 
\item uploading songs
\item voting
\item subscribing
\end{itemize}

There must be help available for all functions in the form of text. This help must be accessible from within the client \\*
Users must not be required to subscribe to a channel in order to listen to it. \\*
Users must be required to be subscribed to a channel in order to vote on the channel. \\*
If a user unsubscribes from a channel, all votes made by that user must be removed so as to not affect track ordering. \\*
Users must be able to see all the songs contained in a channel. \\*
Users must be able to upvote and downvote the last 5 songs that have been played on the channel while they were listening. \\*
Users must not be required to download or install any third party software in order to listen to a channel. \\*

\textbf{Reliability} \\*
The server must not be affected by any errors clientside. All operations requires internet connection. No system failure of any kind should affect any track in the persistence storage. \\*
If a channel on the server crashes:
\begin{itemize}
\item all clients must be notified about the failure.
\item the website must not be affected by the crash.
\item the website must refresh the website with possiblity to listen to the channel greyed out until the channel have been fully recovered on the server side.
\item on the server side, the channel stream must shut down.
\item the error must be logged and reported automatically. 
\item the channel must be safe to use again when all track's identity have been confirmed(via hashing), and none of them are in use.
\end{itemize}
If upload of a track for fails, everything about the track must be removed from the server and the user must be notified. \\*

\textbf{Supportability} \\*
The server architecture may not limit the ability to correct eventual errors. This means that no unessesary coupling exists in the server.
The server and website must be implemented modular so as to ease extendibility.
This means that extensions such as video streaming or downloading of media must not requrie extensive changes in the system architecture. \\*
The server will be running on Windows 7 OS with support of .NET 4.0 Framework.\\*

\textbf{Implementaion} \\*
The server will be written in C\# with the .NET 4.0 Framework and Windows Communication Foundtaion.
The website will be written in ASP.NET and must work in all popular browsers.

\section{Analysis}
This section contains considerations on how to implement the functional and non-functional requirements. This includes the possible solutions, the chosen solution and the reasoning for the choice.

\subsection{Analysis of the datamodel}
The basic domain entities of the system consists of channel, user and track. The rest of the entities supports functionality that is required for the basic entities. \\*
User and channel each represents a unique system entity, while track can represent the exact same data as another track, only seperated by the id and the channel it belongs to.
The decision to not let channels share tracks is because it would require analysis of the mp3 file, to determine whether it is similar, regardless of the name/artist combination.
This design does not limit a possible extention of the system to measure similar mp3 files and update references to avoid redundant data in the file system.
Such an extension does not remove redundant data in the database, which our datamodel does not support. Track has a upvote and downvote count, which vote entities have a functional dependency to,
because for each vote on a track, upvote or downvote is increased. This duplication is made to speed the algorithm, because it does not need to count vote entities when it has counts. \\*
The vote entity exists to prevent users from voting one track several times.
TrackPlay is an entity that represents a play of a track. It is an entity and not an attribute of track, because we want to record the date it was played. \\*
Genre is an entity and not an attribute of channel because we want to make a fixed set of genres to choose from when creating a channel. 


















\end{document}