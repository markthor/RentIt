Testing strategy.
This paragraph will explain how we went about testing our software; it will start with a description of how we tested
against the requirements of the product, followed by our argumentation that those tests indicate that the product meeting the
requirements. It will also contain 

<LAV TESTS PÅ REQUIREMENTS OG SKRIV OM DET HER>

Besides testing on the requirements of the software, we also did basic unit testing. Each unit tests signature use the 
following template:

**** public void <Tested class>_<Tested method>_<Parameter or Behavior>_<The parameters/behavior tested> ****

It was not possible to write unit tests for all methods in all classes, therefore we prioritized testing the methods of 
critical components. That meant the "Controller" and "TrackPrioritizer" classes (HVAD MED STREAMHANDLER?). One could argue 
that the webservice class is also a critical component, but since every method in the webservice class is mirrored in the
controller, it would make little sense to spend resources on it.

It was the intention that every method in the "Controller" class should be tested for all parameter combinations together 
with behavior testing. This turned out to be more time consuming than first anticipated, and therefore some of the tests
only test for the behavior of the corresponding method.












------------- det gamle står nedenunder -----------



Validation: 
	All public methods handle their own parameter validation.
	We do not test argument combinations for methods.
	We only test method behaviour.


All test method will follow the following naming convention:

	<name of class this method tests>_<name of method this unit is testing>_BehaviorTest_<the behavior this method is testing>	

example:

	public void MergeAlgorithm_Merge_BehaviorTest_RemoveTextFromMiddle()
        {
            MergeAlgorithm m = new MergeAlgorithm();
            String[] original = new String[] { "Orig", "ina", "l Text" };
            String[] latest = new String[] { "Orig", "l Text" };

            String[] merged = m.Merge(original, latest);

            Assert.AreEqual(latest.Length, merged.Length);
            for (int i = 0; i < merged.Length; i++)
            {
                Assert.AreEqual(latest[i], merged[i]);
            }
            // This is good
        }