Data storage



transferring data back and forth between clients and the server. Mostly the server will be transferring bits of the songs to the client. The songs can either be stored as a file on the file system or in a database. 



A central part of the system is data storage because the majority of the use cases relies on retrieving or saving data online or offline. The client application requires data storage for a few users, making the performance for retrieving documents less relevant. The server stores data for all users of the system, which in a large system could reduce performance for most use cases. Therefore the performance of the system is improved by storing data in a database. Another thing to consider is the flexibility that a DBMS brings. If the system shall support additional use cases in the future, requiring new data retrieval queries, the DBMS can maintain sufficient performance with secondary indexes.

The content of the documents which should be stored in the database have very variable size. As databases shall allocate a certain amount of space for each attribute in each tuple, storing the content of the document in the database raises a problem. It is not intended to make any restrictions on the length of a document. To solve this the database could store the path to a file, which is located in the servers file system. The file system is very efficient at retrieving files at a specific location. However, this solution makes transaction rollbacks and data recovery more complicated and less reliable. The system does not need the transaction functionality of the DBMS, but recovery and backup could be important as users store valuable documents in the system. The performance gained by using this solution is not easy to predict. However, a research paper\cite{Russel} suggests that it is faster with objects over a certain size, which very large documents could obtain. If the database were to contain pictures, supporting it with a file system would improve performance.

The relational database should contain the objects modeled in the Domain Model. Users and folders have two separate tables in the database. Documents can be modeled in two ways, because all editions of a document should be saved. The simplest one is to make a single table for all documents and editions of documents. An edited document is simply saved as a new document with a common key to link it to the previous version. As document has a title, and the edited document should have the same, this duplicates data and violates BCNF. The original document is identified only by comparing all the editions to find the earliest creation data. Clearly this simple solution has some drawbacks.

Another solution creates a second table with document revisions to distinct between original documents and revisions. This makes retrieving of the original document and retrieving of revisions(for revision history) simpler and faster. It does complicate the task of loading the latest document because a check for the eventual existence of a revision shall be done, alternatively the document with the latest time stamp is the latest revision too.

A considerable benefit with the document revision model and the filesystem support is the ability to save diff\footnote[1]{File containing the difference between two files as an edit script} files in the database. Diff files are smaller than document files and to maintain good performance, these should be stored in the database. This is a very effective data compression mechanism, which could be important if lots of revisions are made of large documents. This improvement would require the diff algorithm to work efficiently, else it would put a considerable CPU requirement on the server, depending on the time complexity of the algorithm and the number and frequency of synchronize requests.